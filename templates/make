{{ header }}
{{ command }}
package {{ .Package }}

{{ if .Imports }}
import (
    {{ range .Imports }}
    "{{ . }}"
    {{ end }}
)
{{ end }}

type {{ .Model }} struct {
    {{- range $col := .Columns }}
    {{ .Name }} {{ .Type }} `db:"{{ .DBName }}"{{ range .Tags }} {{ . }}:"{{ camel $col.Name }}{{ if $col.Nullable }},omitempty{{ end }}"{{ end }}`
    {{- end }}

    db *DB
}

{{- $model := camel $.Model }}
{{ range $op := .Operations }}
{{- if eq $op.Name "set" -}}
{{- range $arg := $op.Args -}}
func ({{ $model }} *{{ $.Model }}) Set{{ pascal $arg }}({{ $arg }} {{ index $.ColumnTypes $arg}}) error {
    {{ $model }}.{{ pascal $arg }} = {{ $arg }}
    const query = `UPDATE {{ $.Table }} SET {{ $arg }}=$1 WHERE {{ $.PrimaryKey }}=$2`
    _, err := {{ $model }}.db.Exec(query, {{ $arg }}, {{ $model }}.{{ pascal $.PrimaryKey }})
    return err
}

{{ end -}}
{{- else if eq $op.Name "get" }}
{{- range $arg := $op.Args -}}
func (db *DB) {{ $.Model }}By{{ pascal $arg }}({{ $arg }} {{ index $.ColumnTypes $arg}}) ({{ $model }} {{ $.Model }}, _ error) {
    {{ $model }}.db = db
    const query = `SELECT * FROM {{ $.Table }} WHERE {{ $arg }}=$1`
    return {{ $model }}, db.Get(&{{ $model }}, query, {{ $arg }})
}

{{ end -}}
{{- else if eq $op.Name "select" }}
{{- range $arg := $op.Args -}}
func (db *DB) {{ plural $.Model }}By{{ pascal $arg }}({{ $arg }} {{ index $.ColumnTypes $arg}}) ([]{{ $.Model }}, error) {
    const query = `SELECT * FROM {{ $.Table }} WHERE {{ $arg }}=$1`

    var {{ plural $model }} []{{ $.Model }}
    if err := db.Select(&{{ plural $model }}, query, {{ $arg }}); err != nil {
        return nil, err
    }
    for _, {{ $model }} := range {{ plural $model }} {
        {{ $model }}.db = db
    }
    return {{ plural $model }}, nil
}

{{ end -}}
{{ end -}}
{{ end -}}