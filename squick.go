package squick

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/demget/squick/internal/driver"
	"github.com/go-openapi/swag"
	"go/format"
	"log"
	"os"
	"text/template"

	"github.com/gertd/go-pluralize"
	"github.com/pkg/errors"
)

const header = "// Code generated by squick at %v; DO NOT EDIT."

var (
	//go:embed templates/*
	fs embed.FS

	plur = pluralize.NewClient()
)

type Squick struct {
	tpl *template.Template
}

type Context struct {
	DB      driver.DB
	MaxOpen int
	MaxIdle int

	Verbose      bool
	Ping         bool
	Ignore       bool
	NoPK         bool
	Driver       string
	Package      string
	Model        string
	Tags         []string
	UpdatedField string
}

type Column struct {
	DBName   string
	Name     string
	Type     string
	Tags     []string
	Nullable bool
}

func New() (*Squick, error) {
	tpl, err := template.
		New("squick").
		Funcs(funcs).
		ParseFS(fs, "templates/*")
	if err != nil {
		return nil, err
	}

	return &Squick{tpl: tpl}, nil
}

func (s *Squick) Init(ctx Context) error {
	if _, err := os.Stat(ctx.Package); errors.Is(err, os.ErrExist) {
		return err
	}
	if err := os.Mkdir(ctx.Package, 0700); err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "init", ctx); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, ctx.Package), data, 0700)
}

func (s *Squick) Make(ctx Context, stmt Stmt) error {
	if ctx.Model == "" {
		ctx.Model = plur.Singular(stmt.Model())
	}

	ctx.DB.SetTable(stmt.Table)
	cols, err := ctx.DB.Columns(ctx.Ignore)
	if err != nil {
		return err
	}

	primaryKey, err := ctx.DB.PrimaryKey()
	if err != nil {
		return err
	}

	imports := ctx.DB.Imports()
	driverImport, driverHide := ctx.DB.DriverImport()
	load := struct {
		Context
		Stmt
		Model          string
		PrimaryKey     string
		Imports        []string
		Dependencies   []string
		Columns        []Column
		Blacklist      []string
		ColumnTypes    map[string]string
		ColumnNullable map[string]bool
		DriverImport   string
		DriverHide     bool
	}{
		Context:        ctx,
		Stmt:           stmt,
		Model:          ctx.Model,
		PrimaryKey:     primaryKey,
		Blacklist:      []string{"created_at", "updated_at", primaryKey},
		ColumnTypes:    make(map[string]string),
		ColumnNullable: make(map[string]bool),
		Imports:        imports,
		DriverImport:   driverImport,
		DriverHide:     driverHide,
	}

	for _, col := range cols {
		if ctx.Verbose {
			log.Printf("table=%s column=%s type=%s\n", stmt.Table, col.Name, col.Type)
		}
	}

	load.Columns = make([]Column, len(cols))
	for i, col := range cols {
		load.Columns[i] = Column{
			DBName:   col.Name,
			Name:     swag.ToGoName(col.Name),
			Type:     col.Type,
			Tags:     ctx.Tags,
			Nullable: col.Nullable,
		}
		load.ColumnTypes[col.Name] = col.Type
	}

	if load.UpdatedField == "" {
		if t, ok := load.ColumnTypes["updated_at"]; ok && t == "time.Time" {
			load.UpdatedField = "updated_at"
		}
	} else {
		if t, ok := load.ColumnTypes[load.UpdatedField]; !ok || t != "time.Time" {
			load.UpdatedField = ""
		}
	}

	for _, op := range stmt.Operations {
		if op.Name == "insert" || op.Name == "update" {
			load.Imports = append(load.Imports, "reflect")
			load.Dependencies = append(load.Dependencies, "github.com/Masterminds/squirrel")
		} else {
			for _, arg := range op.Args {
				var exists bool
				for _, col := range cols {
					if arg == col.Name {
						exists = true
						break
					}
				}
				if !exists {
					log.Fatalf("column %s does not exist", arg)
				}
			}
		}
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "make", load); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		if ctx.Verbose {
			log.Println(buf.String())
		}
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, stmt.Table), data, 0700)
}
