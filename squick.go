package squick

import (
	"bytes"
	"embed"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/gertd/go-pluralize"
	"github.com/iancoleman/strcase"
	"github.com/jmoiron/sqlx"
)

const header = "// Code generated by squick at %v."

//go:embed templates/*
var fs embed.FS

var plur = pluralize.NewClient()

var funcs = template.FuncMap{
	"header": func() string {
		return fmt.Sprintf(header, time.Now().Format(time.RFC3339))
	},
	"command": func() string {
		return "// squick " + strings.Join(os.Args[1:], " ")
	},
	"in": func(a []string, v string) bool {
		for _, s := range a {
			if s == v {
				return true
			}
		}
		return false
	},
	"camel": func(s string) string {
		if s == "id" {
			return s
		}
		s = strcase.ToLowerCamel(s)
		s = strings.ReplaceAll(s, "Id", "ID")
		return s
	},
	"pascal": strcase.ToCamel,
	"plural": plur.Plural,
}

type Squick struct {
	tpl *template.Template
}

type Context struct {
	Verbose bool
	Ignore  bool
	DB      *sqlx.DB
	Driver  string
	Package string
	Model   string
	Tags    []string
}

type Column struct {
	DBName   string
	Name     string
	Type     string
	Tags     []string
	Nullable bool
}

func New() (*Squick, error) {
	tpl, err := template.
		New("squick").
		Funcs(funcs).
		ParseFS(fs, "templates/*")
	if err != nil {
		return nil, err
	}

	return &Squick{tpl: tpl}, nil
}

func (s *Squick) Init(ctx Context) error {
	if _, err := os.Stat(ctx.Package); os.IsExist(err) {
		return fmt.Errorf("directory %s already exists", ctx.Package)
	}
	if err := os.Mkdir(ctx.Package, 0700); err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "init", ctx); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, ctx.Package), data, 0700)
}

func (s *Squick) Make(ctx Context, stmt Stmt) error {
	const (
		queryColumns = `
			select column_name, data_type, udt_name
			from information_schema.columns
			where table_name=$1`
		queryPrimary = `
			select kcu.column_name
			from information_schema.table_constraints tco
			join information_schema.key_column_usage kcu
				on kcu.constraint_name = tco.constraint_name
				and kcu.constraint_schema = tco.constraint_schema
				and kcu.constraint_name = tco.constraint_name
			where kcu.table_name=$1 and tco.constraint_type='PRIMARY KEY'`
	)

	var cols []struct {
		Name string `db:"column_name"`
		Type string `db:"data_type"`
		Udt  string `db:"udt_name"`
	}
	if err := ctx.DB.Select(&cols, queryColumns, stmt.Table); err != nil {
		return err
	}

	var primaryKey string
	if err := ctx.DB.Get(&primaryKey, queryPrimary, stmt.Table); err != nil {
		return err // TODO: make primary keys optional
	}

	load := struct {
		Context
		Stmt
		Model        string
		PrimaryKey   string
		Imports      []string
		Dependencies []string
		Columns      []Column
		Blacklist    []string
		ColumnTypes  map[string]string
	}{
		Context:     ctx,
		Stmt:        stmt,
		Model:       plur.Singular(ctx.Model),
		PrimaryKey:  primaryKey,
		Blacklist:   []string{"created_at", "updated_at", primaryKey},
		ColumnTypes: make(map[string]string),
	}

	for _, col := range cols {
		if ctx.Verbose {
			log.Printf("table=%s column=%s type=%s udt=%s\n", stmt.Table, col.Name, col.Type, col.Udt)
		}

		colType, ok := columnTypes[col.Type]
		if !ok {
			if !ctx.Ignore {
				return fmt.Errorf("unsupported %s column type", col.Type)
			} else {
				colType = "interface{}"
			}
		}

		if imp, ok := columnImports[colType]; ok {
			load.Imports = append(load.Imports, imp)
		}

		colType += udtTypes[col.Udt]

		load.ColumnTypes[col.Name] = colType
		load.Columns = append(load.Columns, Column{
			DBName:   col.Name,
			Name:     strcase.ToCamel(col.Name),
			Type:     colType,
			Tags:     ctx.Tags,
			Nullable: false, // TODO
		})
	}

	for _, op := range stmt.Operations {
		if op.Name == "insert" || op.Name == "update" {
			load.Imports = append(load.Imports, "reflect")
			load.Dependencies = append(load.Dependencies, "github.com/Masterminds/squirrel")
		} else {
			for _, arg := range op.Args {
				var exists bool
				for _, col := range cols {
					if arg == col.Name {
						exists = true
						break
					}
				}
				if !exists {
					log.Fatalf("column %s does not exist", arg)
				}
			}
		}
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "make", load); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, stmt.Table), data, 0700)
}

var columnTypes = map[string]string{
	"bigint":            "int64",
	"boolean":           "bool",
	"character":         "string",
	"character varying": "string",
	"date":              "time.Time",
	"integer":           "int",
	"real":              "float64",
	"serial":            "int",
	"text":              "string",
	"json":              "types.JSONText",
	"ARRAY":             "[]",
	"USER-DEFINED":      "string", // TODO: distinguish enums

	"time without time zone":      "time.Time",
	"time with time zone":         "time.Time",
	"timestamp without time zone": "time.Time",
	"timestamp with time zone":    "time.Time",
}

var columnImports = map[string]string{
	"time.Time":      "time",
	"types.JSONText": "github.com/jmoiron/sqlx/types",
}

var udtTypes = map[string]string{
	"_varchar": "string",
	"_text":    "string",
	"_int4":    "int",
	"_int":     "int",
	"_float4":  "float64",
	"_bool":    "bool",
}
