package squick

import (
	"bytes"
	"embed"
	"fmt"
	"go/format"
	"os"
	"text/template"
	"time"

	"github.com/gertd/go-pluralize"
	"github.com/iancoleman/strcase"
	"github.com/jmoiron/sqlx"
)

const header = "// Code generated by squick at %v."

//go:embed templates/*
var fs embed.FS

var plur = pluralize.NewClient()

var funcs = template.FuncMap{
	"header": func() string {
		return fmt.Sprintf(header, time.Now().Format(time.RFC3339))
	},
	"in": func(a []string, v string) bool {
		for _, s := range a {
			if s == v {
				return true
			}
		}
		return false
	},
	"camel": strcase.ToLowerCamel,
}

type Squick struct {
	tpl *template.Template
}

type Context struct {
	DB      *sqlx.DB
	Driver  string
	Package string
	Model   string
	Tags    []string
}

type Column struct {
	DBName   string
	Name     string
	Type     string
	Tags     []string
	Nullable bool
}

func init() {
	strcase.ConfigureAcronym("id", "ID")
}

func New() (*Squick, error) {
	tpl, err := template.
		New("squick").
		Funcs(funcs).
		ParseFS(fs, "templates/*")
	if err != nil {
		return nil, err
	}

	return &Squick{tpl: tpl}, nil
}

func (s *Squick) Init(ctx Context) error {
	if _, err := os.Stat(ctx.Package); os.IsExist(err) {
		return fmt.Errorf("directory %s already exists", ctx.Package)
	}
	if err := os.Mkdir(ctx.Package, 0700); err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "init", ctx); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, ctx.Package), data, 0700)
}

func (s *Squick) Make(ctx Context, stmt *Stmt) error {
	var cols []struct {
		Name string `db:"column_name"`
		Type string `db:"data_type"`
		Udt  string `db:"udt_name"`
	}
	const query = `select column_name, data_type, udt_name from information_schema.columns where table_name=$1`
	if err := ctx.DB.Select(&cols, query, stmt.Table); err != nil {
		return err
	}

	load := struct {
		Context
		Model      string
		Imports    []string
		Columns    []Column
		Operations []Op
	}{
		Context:    ctx,
		Model:      plur.Singular(ctx.Model),
		Operations: stmt.Operations,
	}

	for _, col := range cols {
		colType, ok := columnTypes[col.Type]
		if !ok {
			return fmt.Errorf("unsupported %s column type", col.Type)
		}

		if imp, ok := columnImports[colType]; ok {
			load.Imports = append(load.Imports, imp)
		}

		load.Columns = append(load.Columns, Column{
			DBName:   col.Name,
			Name:     strcase.ToCamel(col.Name),
			Type:     colType + udtTypes[col.Udt],
			Tags:     ctx.Tags,
			Nullable: false, // TODO
		})
	}

	var buf bytes.Buffer
	if err := s.tpl.ExecuteTemplate(&buf, "make", load); err != nil {
		return err
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(fmt.Sprintf("%s/%s.go", ctx.Package, stmt.Table), data, 0700)
}

var columnTypes = map[string]string{
	"bigint":            "int64",
	"boolean":           "bool",
	"character":         "string",
	"character varying": "string",
	"date":              "time.Time",
	"integer":           "int",
	"real":              "float64",
	"serial":            "int",
	"text":              "string",
	"json":              "types.JSONText",
	"ARRAY":             "[]",

	"time without time zone":      "time.Time",
	"time with time zone":         "time.Time",
	"timestamp without time zone": "time.Time",
	"timestamp with time zone":    "time.Time",
}

var columnImports = map[string]string{
	"time.Time":      "time",
	"types.JSONText": "github.com/jmoiron/sqlx/types",
}

var udtTypes = map[string]string{
	"_varchar": "string",
	"_text":    "string",
	"_int4":    "int",
	"_int":     "int",
	"_float4":  "float64",
	"_bool":    "bool",
}
